The majority of this work occurred on the weekend of week 5
- Saturday night etc.


I started by trying to implement the ability to take a photo of multiple numbers, as you can see in first_test.png
But I realised that, for my code to kind of work, the images should be around 544, 900 sized. If not my code is out by a couple pixels, as the vectors are fixed vectors, and hence their length is a constant for all images. As such, i needed a image with 2 numbers, and a operator that matched the size of 544, 900. I went into google drawings and typed 1+2, centre justified it and vertically centered it and voila there was my image.

I tried running my code with my existing main file that is visible in Week-five-half-2, but there was an error from matlab which said that the values for the matrices(x, y) was less than 1. After a while I realised that the code was actually reading the second number 1st, because as I mentioned last week my code takes the first 0 it encounters and attempts the logic for each number on that pixel. The problem is that numbers have varying heights, and hence the two was read before the 1 because it is taller than the 1. Resultantly, I needed to divide the image into 3 parts

I decided it would be best to create a function to not only divide the image but also to pass each part of the image to the finding(numbers) functions I had created. I would name this the 'callerfunction' as it called each other function. I know that I have to make this a class soon, because it needs to encapsulate the functions, and that will be much cleaner than having it be a function. Likewise, I am contemplating using inheritance for some numbers such as 6 and 9, 8 and 3 and 1 and 4, but we'll see how that turns out.

The first part of the image needed to be the first integer, the second the operator, and the third the final integer. These are the typical components for arithmetic operations. To divide the image I took a relative look at where each element of the arithmetic operation sat, and determined that I needed a matrix for each third of the image. I would do this by taking my preexisting new-array which was filled with 0's and 255's and divide it such that the first matrix ran from 1:1 to row:0.5column-30. 0.5*column-30* is the column that was between the first number and the operator. Thus if I wanted to search for the first number I would have to iterate to the pixel in the last row and this column. Next I had to find the column that separated the operator and second number, this was 0.5*column+15*. Hence, to check what the operator was I would need to iterate from 1:0.5*column-30* to row:0.5*column+15*. Finally, to find the third number I just needed to iterate from that second bound (0.5*column+15*) to the final column of the 'new_matrix'. 

I encountered some problems herein, however. The primary problem was that my dimensions had changed slightly from the initial images I used. This just meant I had to scale each vector down by around 2 - 3 pixels. Once I did this my code worked. 

The function 'caller_function', needed to return an array, which contained the first number, operator, and third number. These elements would then be read by the main function and the result of the arithmetic operation would be printed out. My problem here was that the numbers were being saved as strings, but a simlpe str2num() conversion worked and I got the output I needed.

To talk through the caller_function in more detail:
The function itself produces three new matrices for each third of the image. conditional statements are then used to test the output of each finding_number function. This works because my code returns 0 if the number being searched for was not found and 1 if it was - binary. The conditonal statements in 'caller_function' are simply and ternary statements are relied upon as otherwise it does not work. Each finding_number function is called with the matrix that must be searched as a parameter for the function. And if 1 is returned - if its that number - the number is saved in a variable and that variable is, at the end of the function, added to the array of the caller_function, and returned to the main function.
